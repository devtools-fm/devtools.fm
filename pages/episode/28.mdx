---
title: Steve Sewell - Builder.io, partytown, Qwik, mitosis
youtube: https://www.youtube.com/watch?v=pZixOZENq7Y
spotify: https://podcasters.spotify.com/pod/show/devtoolsfm/episodes/Steve-Sewell---Builder-io--partytown--Qwik--mitosis-e2134gd
tags: technology, web, open source, worker thread, front end, partytown, Qwik, mitosis, builder.io
---

<!-- TAB: SHOW NOTES -->

This week we have an exciting episode that peers into the future of the web.
Steve Sewell is the CEO of Builder.io, a company that aims to be the Photoshop of building websites.
They've built some clever tools come together to render pages insanely fast. join use for this fascinating conversation.

<!-- LINKS -->

- [Builder.io](https://www.builder.io)
- [mitosis](https://github.com/BuilderIO/mitosis)
- [qwik](https://github.com/BuilderIO/qwik)
- [partytown](https://github.com/BuilderIO/partytown)

## Tooltips

### Andrew

- https://peeky.dev
- https://corset.dev

### Justin

- https://www.lovehulten.com/
- https://blockprotocol.org/
- https://github.com/lirantal/lockfile-lint

### Steve

- https://www.builder.io/c/performance-insights

<!-- Paste show notes -->

<!-- TAB: SECTIONS -->

[00:01:14] Builder.io
[00:11:17] Qwik.dev
[00:23:50] Mitosis
[00:29:00] Replayable vs Resumable
[00:34:07] Partytown
[00:48:26] The Future of Web
[00:56:32] Tooltips

<!-- TAB: TRANSCRIPT -->

# Episode 28

**Steve:** It's just like, what the heck? I think it just, you do, you don't realize how fast this stuff is until you experience it. And that's why we're losing our minds. We're like, we're not going to bog us down once you hit that sort of peak performance level of just like entire page load in milliseconds. It's just impossible to go back from.

**Andew:** Hello, welcome to the dev tools FM podcast. This podcast about developer tools and the people who make them I'm Andrew. And this is my co-host Justin.

**Justin:** Hey everyone. Today our guest is Steve Sewell who is the CEO and co-founder of builder.io. Steve, we're really excited to have you on is there anything you'd like to tell our guests about yourself?

**Steve:** No, nothing in particular. I think we'll get into all the specific things or maybe the thing is I care a ton about web performance. We're gonna talk a lot about that today and empowering everybody in the world to be able to work with the same tools that developers use.

Great tools with developers, put them in the hands of everybody. And I think we'll touch on that plenty. And so I'm thrilled to be here and chat about all this stuff

**Justin:** Yeah. Awesome. Awesome.

#### [00:01:14] Builder.io

**Justin:** Well maybe we can just dive right in. So you have started help start a builder.io which is a sort of a Wiziwig website builder. So can you, can you kind of talk about the product and sort of your motivation for starting it and what y'all's goal

**Steve:** Yeah, absolutely. So there's really two elements to this. Try and weave them well together and I'll try not to ramble too long. It could be long-winded. But it's really twofold. So I originally way in the past, never actually set out to be a developer myself. I was obsessed with software products. In fact, when I was going to college, the iPhone 3g had just come out/

which had the app store, which was like, I had to make an iPhone app. Like that was the crazy thing, except I don't know how to code, you know, so it was this big question of like, well, how do I learn that? And I learned best incrementally. I watch a good talk the other day where they called it just-in-time learning like just in time, compilers, like, just learn as you need. I think that's better for many, especially me than trying to learn everything before you start getting your hands on something. And so I went the road of trying to learn design tools and I learned like Photoshop and after effects.

And those are generally considered difficult tools on the design side robust, but there are a lot easier to learn than the next thing I tried, which was coding. So I remember at the time they get like, you know, Photoshop, you can make amazing visual effects. After effects you can make amazing motion effects.

I just needed the next app to make the interactive effects, so to speak. Right. Of course, to kind of find you're reaching for thin air or you find tools like Dreamweaver or just like really janky old stuff, and it's not doing what you need. Yeah. And so I was like, you know, arrogant, I guess I'm like, I'll just teach myself to code. It can't be that hard! Big way, harder than I expected, way more esoteric. I expected everything was just not what I expected. And I'm glad I have the skillset now. It's very, very valuable skillset to have now, but I've been obsessed with like, how can more people learn this stuff the way that I naturally learn what could happen if everybody could learn this in a natural way.

It's a lot like way in the past. There's this old story that like Steve Wozniak made the apple one then realized that he worked for HP. HP gets all rights to all intellectual property he made. He made one of the first like personal computers becomes massive company. Obviously HP would say, yes, we want to own that. But like the old fable is that he like went to their executives and they basically laughed at him.

And they're like, why would business machines make sense for consumers? It's too hard. It's too complicated. It just makes no sense. And I think coding is very similar. I mean, it took them 30 years to go from the apple one to, you know, a few years to the apple two commercially successful, still very difficult.

Macintosh came out. Point, clicked out, can drop Wildy innovative . Still pretty difficult. And now we're about 30 years from that Macintosh and we have the iPhone. It's an unheard of idea that a four year old could just pick up a computing machine and just figure out how to play games, make music, draw, make art and stuff like that.

It's a crazy idea. And I think we have a similar sort of trend going on with coding of like this crazy thing. That's difficult to learn. It's becoming easier to learn there's boot camps and stuff, but we can potentially make it that less next level, more visual, more intuitive.

Now where I actually realized there's an obvious sort of market opportunity here. Like something that was being unfulfilled is I was doing a startup that got acquired by a company called ShopStyle. We did a rebuild of their site. We built it on angular. We did, you know, it was a headless site before people used sort of headless headless commerce of 2015. It was early time for that.

We solved a lot of stuff on the open source side, around angular performance. And this. And we realized though, that there was a big missing piece. I didn't think about content management. I thought about how the developers would build the site. I did not think about how the marketers would manage the site.

And I realized that e-commerce is a marketing machine. It's like test a thousand versions of the homepage every day to see the conversion impact, throw up new landing pages for every new product, every new possible ad social campaign, email campaign. I mean the needs are never ending. And so we ran into this problem where like, wait a second.

There's an infinite amount of needs the marketing team had. And there's only so much time we can code things. And there's only so much you can structure in a CMS, you make a template, you make a form, but the next thing comes in. Well I need a new section? I need a product. I need a newsletter signup. I need all these things.

And we got to the point where we had this angular site, but we had no good tools here. And the marketing team would get frustrated and be like three months to get a new page. Developers hated the work. I mean, it's pixel pushing. I think nothing, a developer hates more than to build a page that lives for one day.

It's a one day sale that has a unique page just for it. And then it goes in the trash. Developers like to build things that lasts that scale, that add value over time. Right. And so constant tension. And we realized something, which is at one point they reached for web flow and they said, Hey, this page we've been asking for, for months, we made it in like two days in web flow, like just kind of copy paste it onto the angular sites.

And we had to have a lot of discussions. Like it doesn't work that way. You don't just kind of copy pasta. You don't kind of embed not with good performance, not with the ability for our site analytics to actually work within the contents of the web flow content. It just, all this stuff. So then they're, they're clever.

They're like, well, why don't you put all the shop style stuff, the product catalog and search and stuff into web flow. And it was also like that doesn't work either, right? But it became obvious that this big company problem would be solved if they had a no code solution like web flow. But if it was composable, like any other software, plug it into angular and use angular components, render out to angular code, plug into shop styles, product catalog, which was a custom one.

You know, we use some various pieces of content management. Like, could you plug that in? That'd be the ideal solution. The question though is, you know, there's a lot of no-code products, none of which are composable in this way that could solve this problem. So I was losing my mind at this job, like really, it was just becoming a tedious, awful job.

And so I quit, I did a lot of research on, you know, goodness problem be solvable. And I came upon sort of understanding how compiler architectures work like the LLVM compiler that, you know, you can write dozen different programming languages will compile to LLVM. I think these days it's like C, C plus plus objective C, swift, rust. It just goes on and on. And as long as you compile to the LLVM format, they've already written sort of ways of writing code out to all the different machine sort of instructions, all the assembler or simply, or whatever. And so what was interesting about that was I know there was a day in time, like maybe the eighties where people would have said you have to, you can't just generate machine code.

You have to write the code, you have to know the machine specs and how to move bits in an efficient way. And they really realized like, no, actually there's a point where the compiler can be more optimal because there's only so much performance stuff an engineer can keep in their head. Versus the compiler you can keep adding stuff to. So as long as you can compile anything to the IRR, the IRR can do optimizations on itself. Kind of like Babel, where it has like multiple layers and then the final layer outputs other things, the big question was like, could you do this on the front end? Could you make the top level, instead of it being high-level programming languages, make it UIs, could the middle layer be just a data representation that you can read and write in a visual form, like as JSON store in a database, query it and display it where it needed, but could that output either ahead of time or just in time as react, angular, Vue, react, native iOS, et cetera.

Could you do that? And after like a year or two of banging my head against a wall and the answer was, yes, you can do that.

It's very hard and it's hard to get, right. And there's a lot of gotchas and pitfalls, but we did land on yes, you can make a Bozeman low code. You can make it so that the Nike's or whatever of the world.

I don't have to have this problem where, you know, you may start a small business on a tool like Webflow. And it's amazing for the small companies, the individual, et cetera, but at a certain scale that I've seen startups do this all the time, their needs become more bespoke and they throw away all the no code.

They build this react site and now they realize like, wait, oh, the non-developers are like, wait, I don't have drag and drop. I have forms. The forms never have the fields that I need. And like, this sucks. Why can't I go back? And anyway, we see that there's a way we see that the technology works since anyway, I'll stop rambling about it, but that's kind of where we are today on just plug and play no code that works with your react design system back in front end and just publish, run tests, et cetera, without that interplay between teams, but never blocked.

You never have to migrate off of it. It works with your systems and components of whatever.

**Justin:** A lot there. No, no, no, no. It's great. This is, this is a really, really interesting domain. I've worked with a lot of CMSs and, and having to plug those into a production system. And particularly this, this question of like, how do we give non-technical users of the system who want to push content, customizable content especially, in a way that, that is all the things you said, performant and, and sort of like other things just like works with the technology that you're using.

So, so this is specifically not hitting the web flow, sort of like target you're, you're trying to integrate it into an existing app. I'm assuming. So is this like, a richer sort of like, I don't want to say like I frame, but to sort of like give people a conceptual model of like, how this happens.

It's like you have a port or a portal or something inside of your app, and this is where you're injecting sort of like content, is that sort of the, the, the realm of like how you're trying to target it?

**Steve:** Yeah, that's spot on. We like to think of it in terms of pages and sections. So you might have your homepage, everything between your header and footer, like any other page, just builder powered. Unlike an I-frame. It will interface with your components. You're using your design system. The same thing shared in your code base, and you probably will pick sections of other pages.

A lot of it it's about 60% of our customers. E-commerce the, most of my examples are eCommerce, but any eCommerce usually have collection pages and product pages. Collection page we don't tell people to put everything a builder, like all that product sell and search logic. Put that in your code developers, keep it in code.

But there's probably an area above that's like, this is the, you know, organic t-shirts collection. Like that should be in builder. They should be able to put anything in there. Links, you know, run AB tests, look at conversions and stuff, or like product pages. You might have a section on the bottom, like here's the product information, but here's all kinds of content.

The story of the shoes, 3d visuals of the shoes, stuff like that, that the marketing team should just own kind of like your I-frame analogy. This is just your box to do it.

**Andew:** Well, so you guys have built a lot of, a lot of things to support this. Just browsing your website website. The three top ones seem to be Qwik JS, Mitosis and party town. So we'll probably go through each one of those and ask what they are, how they work and why you built them.

#### [00:11:17] Qwik.dev

**Andew:** So the first one we'll talk about is Qwik. So why did you build it and how is it different than other web frameworks?

**Steve:** Yes, this is a great question. There's there's actually a number of reasons why, like everything's settled on this one solution. I'll give a couple of quick ones. The first one is, you know, when a lot of people modernize the front end of their website, a lot of it is for performance reasons. Their monolithic thing is getting slow and they want something fast.

They want JAMstack delivered from the edge and it's flexible for the developers. The problem is when the goal is performance, and to be clear too, you know, the people who manage websites at some scale, like you mentioned, I think web flow is killer for individuals, freelancers or small businesses. But for the mid-market and up businesses that have multiple teams and doing sophisticated things, they don't have those tools.

What those teams absolutely need is they need conversions. They're spending money on ads, they're doing social campaigns. They're spending all this money and resources to get you to the website and the worst thing that can happen. And it happens all the time is the website load so slowly people get annoyed and they just go away.

Right. And that kills your conversions, that kills your whole funnel. And so, we always found that if you're looking at conversions, performance is paramount and Google has a million studies on the direct impact, right? Like Amazon did a study about every a hundred milliseconds, cost them 1% in sales. So that's like a hundred milliseconds it's like millions of dollars. Right. And there's about at least six other studies we list in other websites that all show the same thing. It's just slow site people disappear, which makes sense. You're on a beautiful native app. You swipe up to some store. If the store is super janky, you'd be like, ah, I'm back to Instagram or whatever you're on.

Right. Tick tock, et cetera. And so, What you find though, is people start by having a pretty fast site, like the thing about performance that some people like the non-development non-developer people to understand is it's not like an engine where you had more horsepower, it gets faster. It's the reverse.

It's kind of like a Zepplin. And when you add weight, it gets slower. So any sites fast, you could go to example.com, which is just a load of text. Put that in Google page speed insights, a hundred out of a hundred perfect website. It is because there's nothing on it. And so people will make a new website.

They'll use like a love. Next. We use next.js like crazy, and we make a next.js website. They'll put a little bit of content on it and there'll be like 90, out of a hundred. I rock that is great until you realize that you need a lot of additional tooling on it. You need a lot of first-party code. You need all kinds of things, the react components, and do all sorts of awesome crazy stuff.

Pull the product catalog, render out, you know, interesting things. Sometimes you need those to be personalized per visitor. So people who shop men's products, the men's and women's women's, you can't statically generate it all. You start thinking about AB testing, most AB testing tools out there. They use blocking Java scripts.

The script at the top of the page blocks us from rendering inject stuff in the Dom reacts kind of goes crazy. It creates a performance nightmare. Then the marketing team has a pop-up solution. So you add more JavaScript that launches popups when needed and this stuff, ads and ads and ads until that beautiful fast site is just not.

And we've seen this time and again, and you can look at like the, the Chrome real user experience data set, this giant data set and big query of web performance. And you'll see the average website on mobile in real world in the field. It takes an eternity to load, and I'm not talking about examples. Let's talk about real production websites and the reason why is they have a lot of need.

And every framework starts fast and then get slow. As we add things on and bundlers are not magic. You add another import to another thing and that's consumed and run on every page all the time. So what's awesome about having this sort of like compiler infrastructure, where you can take a data representation of the entirety of a page, and then I'll put it to any front end.

Technology is you can start going, oh, well, what front end technology was get as good score because we know people, our customers care about performance. They'd look at our website's performance and our site was getting like 60 out of a hundred. That wasn't that good. And I was kind of going crazy. I was doing everything to optimize every bit of an image in every little, you know, CSS.

If the line wasn't needed, it wouldn't be included. And then one day I'm losing my mind. I cannot get the thing to work faster. And so I'm like, you know what, I'm just gonna sort of hacking and slashing. And what I did is I just commented out all the script tags. So no scripts were important. I pushed that up to Vercel or something or ran page speed insights on it.

And like, I was fighting for like one point, like I wanted to get from 60 to 61. And I think shot to a hundred and I was like, what the heck? And I was like, wait, this is obvious. The typical react app with third-party scripts and all this stuff is downloading a ton of JavaScript. It's parsing it, it's executing it

and then it's getting to the I'm ready to be used state on a mobile network and a low power device. That actually is very time-consuming process. That makes sense. Very slow. And so that's where we're like, oh crap, Java script. This thing we love this, the J in JAMstack is the problem. And that's kind of an issue.

And so the question became well, can you load JavaScript differently? Or can you defer the loading of the Java script? Or you can do weird tricks to make it so that you can just load HTML nothing's faster than HTML. HTML can load instantly. Assuming the images in the HTML are optimized and the CSS is not bloated.

It's only styles that are needed or just something close. If you could just deliver HTML it's wicked fast. So we were working on like this bespoke compiler technology to compile it out to HTML and lazy load JavaScript. And then I met Miško creator of angular, all this stuff, and he was like, Hey, I'm working on something new.

I call it, he called it qoot back then Q O T He is like I have this framework called cute. That can deliver applications as pure HTML. And you never need JavaScript until absolutely needed. And what was funny is almost nobody understood how important and how impactful that was. He was actually almost frustrated that people didn't get how amazing that was.

And it's inspired by technology. Google uses internally called Wiz. So Google search and really core google products use a similar technique of just HTML. The HTML has like paths to where you can find JavaScript in the HTML. And it has what Quik has as well, which is we call a bootloader a Qwik loader, which is a little bit of JavaScript.

It's the only JavaScript to load on the page. It's like 500 bytes. It's nothing. And just listens to events on the page. And if the target of the event has some special attribute that links to a JavaScript path, it uses a dynamic important. It executes that JavaScript and that simple technique alone makes it so that you can deliver pages as pure HTML.

And as the user interacts, it just pulls tiny bits of JavaScript. Almost imagine like you were back in the days of writing jQuery, where you literally only wrote the minimal code to manipulate that Dom node or whatever it was. And so Qwik was a hundred percent sort of Miško creation that earlier forms early forums had wildly wacky DX and stuff, because it's a hard set of problems.

People don't realize that this take on front end frameworks that are very sort of HTML first, they avoid any blocking JavaScript. They avoid downloading hardly really any JavaScript and they require no hydration. You don't have. to Download the entire application in the browser. And then rerender the whole thing, even though it's hydrating into the same Dom nodes, you don't have to execute all that code. Again. It ran statically on the server. It doesn't need to rerun. You should be able to pick up where it left off.

And so, I know we have other sort of topics around this, so I won't go super deep down the rabbit hole just yet. But the point was just realizing that pages needs to load fast. The only way is to reduce JavaScript or delay the loading as much as possible and Qwik was this wild solution that, and we hooked it up.

We proved it out. We, we hooked Qwik up to our compiler and started running speed tests on all of our customers content and just everything was 100 out of a hundred. And we were like, whoa, this is, this is impactful. And yeah, that's how we ended up sort of where we are.

**Justin:** Yeah, that's awesome. I mean the web has come a long ways since the days of jQuery in particular. So, I mean, it used to be like here, we have mostly HTML and we'll sprinkle on some, some behavior. And that is like arguably very, very fast. The, I th I think the, the sort of revolution came when we had like a component model that was introduced where we can think, start thinking about like segments of UI is like this encapsulated functionality. We've been expressing that in JavaScript. And it, you know, if you think of, there's a saying of like, you have a pit of success, well, we have a pit of failure, right. Where it's like every little piece of functionality that we want to add is more Java script. And, and, you know, it's like death by a thousand cuts.

It's like, oh, well let's just use this component framework. It's like, well, this component framework is 300 kilobytes. It's like, okay, well maybe that's fine, but we'll use this other thing. And this other things like 250 kilobytes. So it's like, you know, before, you know, it you're like you've got 750 kilobytes of just like vendor stuff that you're there, you're shipping down and, you know, size may, or nor may not be important, but like execution costs is a real thing.

So like there's all this stuff that's, that's true and valid. And it's something that react fights with. You have like svelte and vue who like give you a sort of component framework via templates. And they can like do some interesting things under the hood to like reduce a runtime. So what is, what is Qwik's model?

Is it, is it closer to like a jQuery esk or maybe if people are familiar with Alpine JS, which is sort of like I'll sprinkle some stuff onto your dominant, em, a little bit more of a component way. Is it closer to that? Or is it, do you have some other representation of how you build components or component equivalents?

**Steve:** No, it's a great question. And I gave a, a tidbit that's misleading earlier about how it like runs like jQuery, but the DX is almost identical to react. So it was completely component driven. I think I agree with you 100% that the sort of revolution of thinking in terms of components was huge and we will never go back from that, right?

It is so impactful and how we build for the web. And it's actually impactful for tools like builder too, because the marketing teams of the world or the non-developers of the world, don't realize that actually developers have Lego blocks in their hands, that they're making pages out of. They're not making things from scratch.

They're making, they're piecing together blocks connecting the dots. It's amazing experience. And so the component model is critical for the marketers too, because they can add the hero and the carousel and the break grid and sprinkle some bespoke stuff in between. That's sort of a hard requirement. So what's wild though, is as you'd imagine that the way Qwik executes cannot execute like react. So the big question is how do you make it feel? Just like react components, JSX capsulated, everything that you said. We want every single property of that, but it can't execute that way. And so that's where things were extraordinarily challenging. And I feel like in this day and age, and actually this has been historically kind of been the case in computer science for a long time, everything, all roads come back to compilers, right?

When you realize the developer needs to think about and reason about and write something one way, but how it executes needs to be a wildly completely different way. And so that's why we have special compiler for Qwik. In fact, we tried to avoid it. Miško actually hates compilers. When they did the Ivy compiler change, it was just this enormous job.

He just had battle scars from him and he's like, I never want to do that again, but it, it became obvious it was needed. So, luckily we were able to able to use a lot of those learnings to put the right constraints in place. The end of the day. Exactly. You write components like react. We compile it out to code that has this wildly unique execution model where it only loads on demand.

Something is hydrated, eagerly. You can lazy load it with whatever strategy you want. Eagerly intelligently based on visibility. Like when a components in view, maybe you prefetch the JavaScript so that when you click it can run hydrate, modify at the Dom however needed, but more or less once the actual mutations on the page need to run, it runs in a react ish way where it can kind of patch the differences with a little bit of compile time, a little bit runtime.

But the really unique thing here as well and how it executes is it can do out of order rendering. What that means is, you know, one of the challenges of I like island architecture a lot because it's a movement towards removing JavaScript. But you do end up with sub apps that have the same problem. You have three apps that all actually need to aggressively hydrate once loaded anyway, maybe sometimes slightly deffered, but usually it's all at once after that.

And what's really unique about Qwik is you could have, you know, say your page component than your hero component than a component inside. But if your hero is like a carousel and you click to view the next slide, you'll actually only download the code for the hero, nothing inside of nothing outside. And it'll only patch in the differences for just that, leaving everything else, untouched on downloaded, which is a wildly new thing and made our lives wildly difficult because actually the way people expect the DX to work was very counter to how D nuances we needed for that runtime to work.

But thankfully, we finally solved that and we are in a state where you get all those wildly granular performance properties with that normal component architecture people like.

#### [00:23:50] Mitosis

**Andew:** Is that component architecture accomplished through Mitosis? Or is that all in Qwik?

**Steve:** Good question. We almost went that road, but no, Mitosis still lives on as a separate thing. What's interesting aboutMitosis and where I think it will have applicability to Qwik is one thing everybody finds rich Harris was svelte, well Rich Harris has been through this rodeo multiple times. Ryan Carniato was solid JS, which is like truly better than react IN every way objectively.

It's just better. It's faster, it's lighter, it's easier. It's just better or Qwik, which we think is extremely better for the types of use cases. That it's great for it, which is really that load time. The problem all of these frameworks have is what you can't build anything on them without an ecosystem.

You need that material UI library, or you need that like great state management thing. You need all these things. And so one reason, one way that we think Mitosis will play into Qwik, pretty heavily is we're working with various teams who make these different UI libraries because they're having this challenge, you know, they support react and or view some support both.

But then Svelte it's getting bigger and solid to begin better and Qwik starting to crop up. And it's just like, how do you support all of these things? That's where Mitosis is can help a ton of just like build your design system here. We'll compile it out to idiomatic code for each of the frameworks.

And now every framework benefits, you know, it's svelte gets more UI kits, component library, stuff like that. And solid.js as well, Qwik does as well. And then you also get providers like us. So biller needs us cause we have renderers that need to run out into all these frameworks natively. And then you could be something like Algolia, that's provides components for search UIs.

Likewise they want to support these frameworks in the meta way. So I think that's where Mitosis will tie into Qwik.

**Justin:** Just for our listeners. So Mitosis is this this like our label, this, this intermediary representation. So you have your, your builder IO components that looks, it does look very JSX E which then compiles down to all of these other frameworks. So it's interesting. It seems like it would be a really hard compiler problem.

So one of the things that always sort of was fond of with likes Svelte and Vue is like in a template, you can constrain your sort of like the runtime code that you have there. You can make some like, easier determinations about how to optimize that. You know, like what it turns into under the hood, but thinking of JSX, which people famously like to say, oh, it's just JavaScript.

Well, JavaScript can be a really, really hard thing to optimize and figure out like, Hey, what is actually needing to run here? Cause you can do whatever you want. Like, and if you have to do runtime analysis or like code execution, path analysis on you, stuff to make optimizations, it gets really, really hairy.

And I don't know if we should go that far down in the weeds, but I am really curious about like how y'all are able to accomplish these sort of optimizations broadly.

**Steve:** No, I can speak to that. That is actually a really, really good observation. You know, more about this topic than a lot of people, because I rarely get asked that question. And that's one of the most important considerations early on. So the short of it is Mitosis has constraints the same way Svelte and Vue do. You actually need to not think of it, like react JSX and think of it like a static template. You'd have to kind of squint your eyes and say, the reason why we chose JSX is purely because we didn't want to invent another templating system and it already works with TypeScript already worked with your favorite tooling, but you can't think of it.

Like we have to, can't just throw JSX elements wherever you want. In fact, somebody made a GitHub issue the other day that I thought was freaking brilliant, where they had a slightly different flavor of it that feels more like Svelte and makes it more clear that there's more static rules to it. But in the short term we emulated react and we've been adding a lot of eslint rules.

And what do basically tell you the constraints and tell you that? Yes, you can't just add random variable assignment and you can't just sprinkle J it is not just Java script it actually is templating static templating first, like svelte and vue, even. So you're gonna have to squint your eyes a bit or wrap your head around it.

And for the longest time, I almost didn't make a JSX reputation representation for Mitosis, purely because I was worried about this principal. And then I saw solid JS Ryan Carniato of having the same problems of needing to do very heavy static analysis. And he built in certain constraints, like the show component before each component, stuff like that.

And I saw it was working, it was elegant and people accepted it. They were able to shift their thinking and use it the right way. And that was like, that was the big aha. I was like, okay, JSX will work. We'll make it work. And yeah.

**Justin:** It reminds me a lot. What of what rich did with Svelte. So it was like for their reactivity, there's like certain syntax that they co-opted, it's like, Hey, this is how you make something reactive. And at first people were like, Hey, this is really weird. But then, you know, it's just the thing to learn. You get used to it.

You're like, oh, okay, this makes sense. But I mean, that, that does. One of the biggest, like, things that I was thinking about is like, oh, well, if it's, you know, if you're just having to dynamically like analyze this JavaScript to figure out like what its dependencies are and all the logic, it's like, at some point there you hit a halting problem where you just have to bail on certain optimizations.

You're like, oh shit. I don't know what's going on here. We're just going to skip it. But so that's, that's pretty cool. That's pretty cool. Like that.

**Andew:** okay. Uh, Going back to Qwik JS for, for a little bit, before we move on to party town. One of the things that seems to mention a lot is resumable versus replayable.

#### [00:29:00] Replayable vs Resumable

**Andew:** So, what is that. and how does it affect the user experience and probably most importantly, how does it affect how I write code? Is code in Qwik? Do I have to think about other things while writing it or do I just write it.

**Steve:** That's a fantastic question. Yeah. So the short of it really quickly I will define resumable versus replayable. So replayable is what you're used to with JAMStack serverside or static, rendering, where, I mean, as you know, I mean, the history of all this stuff really started with a browser oriented focus.

We're just going to render in the browser. And I think, you know, at a certain point, people realized, well, sending a page with a spinner, them downloading JavaScript, and then rendering the page is a little bit wonky, especially as your app gets large. But what you could do is you can send the initial HTML, you can't interact with it.

It's kind of dead HTML. But you people take a moment to process what they're looking at anyway. So you basically do this magic trick of like send HTML, but then go fetch all the JavaScript and render in. And hopefully you didn't click on anything significant in that meantime. Or some things might not work links work, but you know, interactive hamburger menu or something won't work.

And so that worked okay for a while. And tell people started realizing no, the applications are getting bigger. Your job dependencies grow. Bundlers are not magic. If it's imported, it has to be consumed, downloaded, executed, rendered. And so it was creating this problem of the fact that going back to dev definition, you know, replayable is, you know, you basically run your application on a server or, you know, during a static build process, it creates HTML.

You send it, but then that's not functional HTML. You actually have to replay that application in the browser. So now you download all the Java JavaScript, you grab all the state, you fetch requests again, in some cases too, and then you splat it in, right? If you're looking at older school like angular prior to a certain version, it would just do a Dom clobbers just wipe out, replace the Dom.

It would just so fast, you know, there would be no flicker... usually. You would just see the new content. React will preserve DOM nodes, but it is still rerunning every single line of business logic. And then application that your server or your static build already ran. Like it's been computed. It should be re-used as opposed to replayed from scratch as if Miško causes amnesia, like wakes up and is like, I don't know what's going on.

Give me all the code and I'll figure it all out again. Right. And that can be slow on a mobile device, a poor network or a complicated app, which all grow over time. Death by a thousand cuts always happens over time. So resumable is this idea that. Whether statically or on a server, you run your application up to a certain point.

It's the point that you wanna deliver HTML and you do not need to rerun it in the browser. Everything that's been computed has been computed, nothing has to recompute. Nothing has to download the browser can pick up at the state that the server or static build left off. And as you interact, you can continue to then work with the latest state and things only load and modify the Dom or download or, or execute when needed.

And one of the coolest demos of this, I wish I had it, you know, locked and loaded, like packaged, able to do it. But one of the coolest demos that you can take a Qwik app, Miško did this on a live stream the other day, where it's like a, to do list, or I think he did an e-commerce one, but any of it goes, let's just take a to-do app.

You add some to do you check off some boxes and then what you can do is you can go into the dev tools and you can copy the HTML of the body. You can paste it into another web browser, like an empty web browser. You'll see the HTML, but most of us are used to HTML is not an application. It's just the by-product of an application.

So you can't just paste HTML and then interact with it. That doesn't happen. Right. But in Qwik, it can you paste the HTML and then you keep interacting and then it will continue working on the state that it left off. And that's just wild principle. That's extremely impactful for rendering from the edge of the server statically and having a very high performance experience at any size or scale, no matter how big your app grows, you could be macys.com that has a bajillion lines of code.

It's still going to be just as fast to load. And it's only going to render what's needed. It's quite nice. You don't have to worry about adding a dynamic imports and async everywhere. Actually, the Qwik compiler does that. It rewrites all your imports and everything for you. But it has some other interesting principles like debugging time travel debugging is actually a simple process of Snapshotting the HTML state to be able to replay fast-forward and then continue certain tooling around analyzing user behavior is actually extremely lightweight in these contexts because of this resume ability.

So it's this weird principle that Miško came up with. I feel like he just meditated in a cave or something just comes up with these crazy ideas. And then it has all these interesting side effects. Some that are obviously very impactful and some that I think we'll continue to explore over time. The benefits of,

**Justin:** Wild wild.

So talking about wild party towns is actually how I discovered you to begin with historically I've worked at a media company, a big media company, so on brands like food network and HGTV and you know, Google tag manager is like, or Adobe tag manager as it were in that case is the bane of the developer's existence because it's like, oh, you know, we want you to improve performance, but you've got like the marketing team or whoever is like injecting like two megabytes of like stuff in the page.

#### [00:34:07] Partytown

**Justin:** And like, how am I supposed to optimize that? So talk a little bit about like what party town is. And, and I just, I'm really curious to hear about the story of how this developed, like who was the mad scientist who came up with this.

**Steve:** Yes, yes, no. I'm happy to answer all of that. I love this topic. I love party town. It's the weirdest, coolest thing ever. So, yeah. So you got the background, right? And so one thing we ran into is you know, first we were working on getting our website up and running on Qwik, write builder.io. It's get it on Qwik.

Let's have great performance. And Adam, Adam Bradley, creator of ionic, Stencil whole lot of awesome projects. Kept reminding us. He's like, you know, we're going to just get destroyed by third-party scripts. We're going to optimize all of our code, but all the code that's not in our control is just going to wipe us out.

And we're all like, yeah, I know, but it's easier to not think about that. Let's just finish Qwik and then we'll worry about it, you know? And we kept having these ideas and, you know, we were getting further with Qwik and eventually it got to the point and really Qwik, it's working great. It's rendering on our site.

We got to answer the third party problem. And we really didn't know what to do. All we know is we cannot have all that code running on the main thread. And we've learned from experience. Like I think in your experience as you did just telling the marketing team, no, you can't have marketing tools is not a solution at all.

Developers like to think it is, they will fight it. They will try. They'll never win. And if you, I have experienced, you know, working on the marketing and development side of this company who has past companies and mostly on development side, I fully understand why that yes, truly genuinely, no marketing tools means your business will not grow.

It's not an option. And as we know marketing tools, you know, Either blame the tool creators, they write bad JavaScript, or you can just blame the functionality that's required requires JavaScript. It really does needs to load. It could be optimized more. The incentives aren't always there, but it's not a fully solvable problem on the platform side to those who provide the functionality, can't fully solve it either.

And so we really were spinning around two different things. Thing. One was, can you do this stuff on a server? Somehow the problem is, and a lot of people have explored this. Can you do it at the edge? Can do it a server. The problem is those marketing scripts need Dom access. They need to read the cookies and set the cookie.

They need to read the page. They need to inject additional script and maybe need to inject an I-frame or Dom. The server doesn't work. And so the only way it might. This was one of the paths we explored is you run a fully emulated browser. You're on puppeteer on a server, one per visitor, and you have a web socket connection where you're just posting stuff back and forth.

This is, I need this cookie, I need this. But even then the asynchronicity makes the whole thing break down. The JavaScript for these things require the synchronous Dom access that would break all their code.

**Justin:** And probably security concerns there too potentially.

**Steve:** wild ones, so many problems with that, but we were just obsessed because we've identified how fast your site can be.

And I don't know if you've seen it. One thing we noticed early on is when we deleted all the marketing scripts and we had the Qwik version of the page first, the react version of the page, that thing loaded crazy fast. Like sometimes you don't realize it, but we would just post links in slack and you would open up our old site and they would load, like a site does, and you'd open the Qwik site.

It's just like, what the heck? I think it just, you do, you don't realize how fast this stuff is until you experience it. And that's why we're losing our minds. We're like, we're not going to bog us down once you hit that. sort of Peak performance level of just like entire page load in milliseconds. It's just impossible to go back from.

And so we started playing with this idea of like, what about the web worker? We talked about it a lot and we're like, well, that'll never work there's no DOM access, but we're like, yeah, but the web worker would solve it. It's wildly less expensive than this idea of puppeteer and servers, web sockets. It is. I mean, it could be something that's just for free.

It's just open source this and that. The problem of course though, is the window slash Dom access. So the first thing we looked at is amp had created this project. Oh, I'm blanking on it now, but they emulated the Dom in a web worker. So they use something like JS Dom, like a full, pure JavaScript implementation of the documents, Dom window object, API, some stub to some functional.

And they did a lighter-weight version. I, oh, I'm blanking on the name, but we know the person who made that thing. And he told us a lot about what went well, what didn't, what to do, what not to do. His main thing was don't run JS down with the worker, but we ran an experiment. We did an experiment where we ran based on when the worker and we patched JS Dom to message the updates, you know, to message back and forth.

The problem with that though is JS Dom or any Dom emulation is a massive amount of code. And you still have problems of keeping the cookies, fresh, keeping the Dom state fresh. Like if your post messaging every DOM update back and forth, it's still going to be wildly slow thing. And so that's where it was Adam's idea.

Can't remember where he came up with it, but he was like, wait, wait, wait, wait, wait. Okay. And I can't remember what he did it. I, we met up in person one time and I think he was explaining to you that these kind of like, hear me out if we can proxy those global variables. So you'll run normal JavaScript on the web.

worker And you use like the proxy API to say, anytime you're trying to access a variable, that's not there in the local scope. At least we have a hook to say, we could do something there. The problem is we still have to do something asynchronous, but we can intercept that and answer with something. So next question is, how do you make asynchronicity synchronous?

And that's where we found two options. One option we found first, which is the ugliest thing in the world, is it turns out that, you know, it's so funny. I saw a video of the day that called XML HTTP request. XHR this like, what do they call it? They called it this archaic thing. And I'm like, I thought everybody was used to XHR.

That's like how you, I mean, fetch is like the new shiny thing. The XHR is how people have done it forever. Right. And, but they put it. But what we realized is way back in the day, there were facets to do synchronous stuff in web browsers. People want to be easy. They want to be synchronous. So they XHR had us a property to make it synchronous.

So everything on the page would freeze while I fetch some data and then rendered. And obviously people realize that's a very detrimental thing to do on the main thread. They deprecated that, but weirdly enough, XHR for whatever reason exists on the worker thread and synchronous XHR is allowed and, and with no.

And we talked to people on the Chrome teams, the people and on the W3C. And we're like, are you planning on getting rid of this? They're like, no, we're like, okay, we're going to use it. And we're going to use it for the ugliest thing imaginable, but it actually ended up working. I'll explain how it works in a minute.

But yeah, so what we ended up doing is realizing, okay, the combination of synchronous proxies to hook into you're trying to access global browser state plus synchronous XHR that lets us freeze the worker thread, which is not nearly as bad as freezing as the main thread Cause we freeze the main thread.

You can't interact the browser can't render these problems. If you freeze the worker thread who cares? In a certain sense. Right? And so you freeze the thread, you trigger an HTTP request a week, it's goes to slash proxy town. We load a service worker that intercepts that and sends a command to the main thread to evaluate whatever you're trying to do.

I was trying to get the document. I was trying to run a method, whatever, and then send the response all the way back and let the WebWorker thread continue as if nothing magical ever happens. It worked, it worked really well. And Adam came up with a lot of other clever tricks to be able to do function passing and referencing and all this crazy stuff.

So lexical, scope and state all works, but that was, it was crazy thing upon crazy thing. There's so many levels to the mad science that he was able to implement for all of this. The end of the day, you actually have any JavaScript can run in the web worker and it runs. And we also verifed with the lighthouse team that when you're running code in the web worker, as long as it's not, you know, when you're doing when you're doing a performance tests on the web page.

If you, you can download. And we did a bunch of our own tests on this too, but we checked with that team to make sure they're not planning to change this. You can download a gigabyte of JavaScript to the worker thread, as long as it's not like injecting big new things to the main thread. You're not penalized because it truly is out of the concerns of the page loading. The page loaded great. And what most third party scripts are, is just listening to events and just firing off HTTP requests, user click this, you know, image loaded, you know, whatever it is. And so the performance will be slightly degraded in the worker. You know, that third party code will run an ounce slower because it has to do some thread hopping, but your application runs lightning fast.

Every user interaction is lightning fast, and you can finally go back to that point that I made earlier about, you know, people being autonomous. We can go to our marketing team and say, Hey, add whatever script you want in Google tag manager. It's fine. And everything runs great.

And the last thing I'll just leave you with. There's a new set of APIs called Atomics. And we can use shared array buffers to do this even faster, where you don't need service workers. You don't need synchronous. XHR, it's actually an API designs to allow this type of synchronous access across these threads. And that's where we will move. But there was this thing called the specter, like security vulnerability that made it so that it's very, it's difficult to use Atomics today.

But over time we will move from the XHR synchronous sort of hack to Atomics and shared array buffers and everything gets faster. But at the end of the day, even as things are today, main thread is wicked fast all the time. All your third parties are on another thread and it's just seamless. You write javaScript.

And last thing I will add. I know I keep saying last thing. Last thing is we've been starting to write first class party code lately party code. I should keep using that kind of like that. We've been writing party code. We've been writing JavaScript that we know is meant to run in the web worker. We do things like prefetching for Qwik, client-side routing for Qwik, all in the worker, even exploring running all Qwik components in the web worker.

Because of the party town, it makes the DX so seamless. We're kind of like, wow, this is kind of nuts. And it's working really well for performance for load time for all that stuff. It's fun.

**Andew:** Yeah, that, that, I was just about to ask that question since like the docs very clearly say like third-party third-party code is first party on the horizon because I myself have had the thought like, oh man, if I could just run, react in a web worker and just let it, let, let the main thread be idle.

That'd be awesome.

**Steve:** Yes, no, it's exactly what we're exploring. And what we find is the way the frameworks are structured today, there's so much sort of direct hopping between the framework code and the Dom code that the performance is not ideal because there is a small price to pay on thread hopping. So heavy Dom read and writes is not ideal, but I mean, obviously we're making a framework.

I'm like, well, if we designed the framework in mind, the Qwik framework is unique and that it can do every rendering, asynchronous. I can build, you know, you can run, react through party town, but it might not be the most optimum. You can make a new framework though. That's optimized for this asynchronous worlds, a party town, then it could be wildly fast.

Your application could be as big as you want and get all these benefits. And we're also exploring some things that like react server components do where essentially a server, something else other than your application can return essentially VDOM JSON the patches in, we may be able to use the same facets of react 18 to actually allow this to work very performantly in react where it's like the web worker is actually like your server for react server components, and then returning the Dom for the main threat to patch him.

So there's, there is real interesting stuff on the horizon here.

**Justin:** That's bonkers was wild. I, this, this really broke my brain when I first saw it. I was just like, wait, wait. So the synchronicity problem was the first thing I thought about like, how can you do that? The synchronous XHR is, is, is incredibly clever, but there are all of these problems. It's like, you know, if you're serializing this object that has like references or whatever, you know, like, it'd be like all this stuff that you have to just basically call like web worker post message or whatever, and get that over.

And it's that's, I don't like, it's hard to understate how hairy of a problem this is. And the fact that it works is nothing short of just absolute black magic.

**Steve:** I agree a hundred percent. And to be clear, there are many moments where we're like, wait, this is probably just not going to work. Even when we felt we were 80% where like that last 20% is going to kill the whole thing, probably. Luckily again, credit to Adam, Adam solved everything the way he does the reference tracing and everything is ridiculous.

**Justin:** Yeah, that's wild. It does seem like there is. I mean, there's still probably the potential that things won't necessarily work as an expected. You pointed out earlier that, you know, heavy Dom writes or just a lot of message passing generally. And especially if you're passing a lot of data, it can be expensive and can kind of, kind of slow things down.

So if you have, you know, some very poor performance analytics code, which is not unheard of whatsoever, that is like, I dunno, spamming either Dom access or like accessing something like just over and over and over and over again on the window. Like you could very easily get into the situation. Performance for that, I guess isn't great. But maybe it's okay. Like if it's mostly off thread

**Steve:** Yeah. So there's, there's two things we discovered with partytown that are cool here. Thing one is the vast majority is analytics providers. If they do anything slow it runs happily in the web worker. They're not spamming the Dom much. They're usually registering a few event listeners and doing the rest on their own.

But the interesting thing is, you know, when you going back to this idea of components, composability of components, all that stuff, like as a developer, you just want to think about components. You don't want other things touching your page, get off of my page, don't touch it. So what's interesting about party town is it creates this bridge that you can hook into and you can actually say, ha not allowed.

Like it can actually say within that worker and you can put different scripts and different workers by default, they all fall into one. You can actually say, no, you cannot touch the Dom, but you can not read the cookie. So it actually sandboxes other things for some increases to security, privacy, and just sanity.

So to speak your own sanity of being able to say like, no, you're not allowed to read the, this area of the Dom. You're not allowed to write to the Dom. I will handle Dom writing you don't touch, which is, is a nice property of it.

**Justin:** Fascinating. Can you mock stuff going to the web worker? So if it's like, Hey, I want a cookie. Can you just like, give it a whatever cookie you want?

**Steve:** So it uses the same API as proxies that says like, okay, worker's trying to do X. How would you like to respond? You can throw an error. You can turn, null you can turn a bogus string. Another good example of this actually is like, you may want the third parties to have some level of user agents access. You might want them to know that if the desktop versus mobile, but you may not want them to know every detail about the user agent, but the version and everything.

They all use the same parsing. Regexes the general strategies. So you can actually provide a bogus user agent that basically would allow most user agent parsers to identify desktop vs mobile, but nothing deeper than that. So you can still be clear about what I want these third parties to know and what I don't, and that can help with GDPR and other things as well, which is like, you don't get access to certain things until a certain time or never, or in a limited way.

**Justin:** magic. Magic. That's awesome.

#### [00:48:26] The Future of Web

**Andew:** So it looks like we got one question left. This is a question we asked to a lot of our guests that come on, but I think you'll have some, some unique opinions about it. Given all the stuff we've just talked about. What do you think the future of the web will look like?

**Steve:** that's a great question. Yeah. I could ramble about this forever, but I really do think that one big change is in the process of being made and I'm very excited to see it and we're contributing to it. So we care a lot about it. We don't think about it, which is really right now today performance like having a fast site and the flexibility, the ability to update the site, run tests on the site, you build new things on the site or at two ends of a linear spectrum, right?

So I've seen, in fact, I remember one time somebody sent me an example of one website and e-commerce at decent scale that reach a hundred out of a hundred and Google page. And I was like, I don't buy it like no way. And I loaded it up in like, it's true. It actually did. But I realized something I'm like, I've been through this rodeo before. I guarantee the way they did that is by taking enormous amount of sacrifices and what they did as a key part of that is they unplugged every possible tool to customize that page. That page is as hard-coded as anything that's ever existed, to make sure you constrain every possible performance nuance. And so as expected, I checked back a month later to see why is it that page still fast?

No, it wasn't. It was down to like 20, out of a hundred because you realize that website is not a static thing. It doesn't sit there unchanging, especially in eCommerce or similar industries, it has to always change. And that's where it's pick your poison and businesses require change. So that's why everybody.

Start even if they touch the side of spectrum, they just slide back to the side. And that's where you find conflict in between teams, the engineers fighting, stopped doing things. We need to lock down the performance. And the marketing was just like, stop being annoying. We need to promote this business.

You only have a job because we're selling a product through this business. Like, you know, everybody needs to come to terms here. And so I think what we're going to see that I'm very, very excited about is finally, I think the ecosystem is cracking the code and we're not the only ones doing this. Marco did some cool things, astro does cool things.

We think we take these things to the furthest. At the largest scale, we focus on the larger scale a blog site, a hobby site, et cetera. Can you use those other tools and get good performance without doubt. But I think we're finally gonna reach that day and age where we see the web is a much more fluid thing.

You can actually actually be set free and regardless of people's background technical or non-technical, they can be making wild things.

The other day adams.com made this like landing. That was a mix of code and no code. And it was just ridiculous. It had this like canvas motion graphics effects that like the developers made, but they registered it with builder.

And so they dropped it on the page and they customized the details. They put the shoe in the product information on top of it and all these animations of the things and the performance was killer. And it was like, this doesn't happen. You don't a build wildly. Awesome, crazy interactive page B. You don't do it without code.

You don't do it by just dragging and dropping, hitting, publish it's live in a day and see end up with a high performance experience end to end. Like those things don't exist. And I think we're just starting there. I think similar to the personal computer where the Apple 2 was only the beginning, it was just, you know, people could do things without coding.

That's great, but there's so much more to come for the Macintosh iMac, iPhone, all of that. I think we're at a similar thing where we've really found scalable solutions to performance. Just like the apple, I think always knew it could run code performantly. It's just, what can you build on top of that foundation so that you can do interesting wild, 3d, animated iOS games, but still run, you know, perform way under the hood.

And I think we're getting to that point for the web and we're getting to the point where everybody can be not just a content creator, but an actual coder, an interactive experience creator. And I really do think that the second order of effects of democratizing something like this, making it so that it's not the tiny population who knows how to make interactive coding things, but actually make it so that everybody can do literally what anybody else can do, who can code.

Code is not going away. I think it will get more specialized and I love code. I still write code don't I'll do make anything, a builder that I can because it saves me a lot of pixel pushing. But I think we'll see this sort of second order effects of everybody can make wild stuff. And when people can make things, people inspire others, people jump on the bandwagon.

And I do think we'll see some level of Renaissance just like personal computing, the internet, stuff like that when it comes to the creativeness of the web. And we're seeing fragments of that now today, like as just one final example, you know, if you look at any e-commerce website, you'll find that it's generally a thin layer of over a database.

It's a homepage that shows a preview of a couple of products. And then every other page is a collection page or a product page collection page is a grid with different pictures of the boxes. And the product page is just a bigger box with a different picture in different price, in different pieces of text.

It's incredibly boring. And what customers of ours like Everlane have started to do is actually reimagine every page. So like as a Qwik aside, as like a real-world example is I tried to learn to surf recently, Partially successful, partially a failure. It's difficult. And I realized I needed a wetsuit.

And so I went on to Kathleen's website to capitalone.com and I'm like, I need a wetsuit. And I knew about it was good for surfing. It's good for cold weather. Cause Pacifica is freezing. I don't know if either of you ever surfed Pacifica, but it's so mind numbingly cold. I needed a good wet suit and I went online and I saw this grid of wetsuits and I was in the deepest category.

I was in the wetsuits category. There was no other filtering and I'm like, which one do I get? And I'm like clicking through each one and trying to find where in each product page, there is some level difference. And eventually I gave up, my partner convinced me to go to the decathlon store and we walked into the store and the store is better organized.

It had surfing sections. So I went to that. And then in the surfing section, I had the wetsuits and it said, these are the beginner, intermediate advanced wetsuits. This one's good for cold temperature. This one's good for warm temperature. I was like, that is intuitive. I know what's what I need now. I would've never figured that out, clicking through every product page on the website once it's kind of slow too.

So it was kind of painful. And I just bounced at a certain point, which is what happens, whatever everlane's doing now is if you go to the denim page for Everlane, it's not a grid, it's actually these full page sort of explore the different denim options, drill down to what you actually need, and then see as slightly more hand-selected or computer selected set of products to explore. And that's really exciting to me because he, commerce websites have not changed in decades yet. And I know Everlane Everlane, see founder CEO is an investor. I remember last time I met up with him, he was just so excited about how awesome their latest storefront is and how this new store, the physical store was so different than every other one.

And I'm like, wow, that, that passion does not exist on the web in e-commerce in a certain way. It's really just grids on grids, on grids boxes, on boxes, different data in the same boxes. And it's exciting to see now that they have the ability to make the experience unique. If you're shopping denim, it's a different experience than if you're shopping shoes, right?

They're sneakers have a very different look and feel Adam's a similar, the shoes page and the mass page is totally different, is different information. There's a different way to lay it out. And it's when it's easy for people to do you get these magical properties, so I'll stop rambling. But I think the web will get a lot more exciting too.

I'm trying to say.

**Andew:** Well, I'm excited. Yeah. We've had some guests that are like, ah, everything, shit, and it's all going to trash, but I'm excited to see the optimism.

**Steve:** I am optimistic. Yes.

**Andew:** yeah. I even for de script, I could see so many different use cases of ma like it's a problem that we deal with too. Like I spent weeks trying to get our bundle sizes down and then I come back three weeks later, just look at it and I'm like, oh my God.

No. So just to get away from that cycle is going to be a huge revolution of the wheel.

**Steve:** Qwik automates on a cool way, by the way, rewrites all your imports. And hopefully that's an archaic problem of the past very soon that nobody is wrestling with anymore. Yeah. That's our hope.

**Andew:** Yeah. If I never have to open up a bundle analyzer again, I'd be a happy man.

**Steve:** Those are not

**Justin:** I have one Qwik question. Is it, does it require a server? Is it like server-side rendered?

**Steve:** That's a good question.

**Justin:** of the thing?

**Steve:** So, no it doesn't. I mean, you can run a fully in the browser if you want. It's quite performance in a lot of ways, just fully in the browser. But in most cases you'd probably static render. It depends on your use case. Basically we support the same things that Next.js does. So a server, a static and incremental static, or just all in browser is all fair game.

**Justin:** Sweet. Awesome.

**Andew:** Cool. And yeah, with that, we will move on to tool tips.

#### [00:56:32] Tooltips

**Andew:** So, my first and maybe only total tip of the week is something I literally saw today. It's from Matthew CP. He works at Astro, I think, and produces a lot of different, interesting tools that we talked about.

Lucy Lang one time, like a DSL for writing state machines. This is a very different approach on a JavaScript front end framework. So it aims to like completely decouple the interactivity you add to HTML from the HTML altogether. So what it looks like in the end is a very weird take on CSS where you like you target something that's in the HTML, such as like a button or a counter.

And then you have this CSS language to make it interactive. So you can have like increments, the counter, you can affect the text, you can do all different, weird sorts of things. So, if you're interested in, on a wildly different take on front end development, this would be a good place to start looking.

**Steve:** that's fascinating. I did not get this on first look. That's interesting.

**Andew:** Yeah. It's it's, it's, it's a weird take. I've never seen it before. And I'm, I'm interested to see a few like larger examples that show how you could use it.

**Steve:** Agreed, and I'm also curious like repeats and stuff too. I'm sure it's in there. I'll take a look at my own.

**Justin:** Yeah, it's really interesting. It's like, oh, you can tell that they're like really like CSS, like, you know,

**Andew:** And of course, I forgot to say the name. It is corset.dev. And yeah, that's the name? Let's move on to Justin.

**Justin:** So, this is something that Andrew actually shared with me. And I forgot, and I reshared it with him. As it goes. So, there is this website called block protocol.org. And it's I think it's by a company called hash, but they're sort of envisioning this specification for how to describe components in a data format.

This is not a new end or unique thing. Anybody who's ever used a headless CMS has like consumed this sort of thing before. Just another take on like trying to sort of like a rough out. A standardized way to describe certain sets of components to, to give them specifications and then to provide some components out of the box.

And then I would give you the ability to, to register your own components. I thought the presentation of this was really well done. I'm really enamored with the idea of just like generating components from structured content cause in the same way that sort of like Qwik ticks, this gives you this component format that is sort of an intermediate representation of what, you know, all these other framework components could be a sort of block protocol or like structured data for a component is, is very much that in a simpler form, it's like, you know, we'll give you the data to express the component and then you can just sort of like, generate it out.

But anyway. Yeah, it's really cool. If you're interested in this sort of thing, or if you're, I don't know, thinking about making your own CMS or using like a structured CMS or something, and then like, or thinking about how to store the data for your components, this could be some good inspiration.

**Steve:** That's awesome.

So this is a performance tool that we put out. We noticed something learning we had been looking at the performance of websites is typically, and actually I'd encourage you to just throw a website in there. It takes a while to load the performance scores, to put like I'll put like target.com, nike.com.

I don't know some website of decent scale. Cause it usually is more meaty. And then yeah, I

**Andew:** Yeah, definitely not the one I managed. I don't want to put myself on blast like that.

**Steve:** I have a bad, I've been using target as example, cause I don't know anybody to target, but I'm waiting for somebody to be like, will you stop it? To be fair, every e-commerce website or most websites, a certain scale look, look the same in terms of performance scores, but basically here's what we found and why this tool is kind of interesting to us is you can go to page speed, insights or lighthouse, and we'll tell you fix all these things.

What it doesn't do is quantify how much of impact each thing would make. And people get frustrated. They start knocking out things on the list, takes them a month to get through three items and they don't see the performance score move. So what we do is, and this is how we learned the impact of different things on people's site performance.

We will take your website and we'll just run the normal lighthouse. We use Google page speed insights API into the hood. So it's doing a mobile, you know, score. And then what we'll do is we'll proxy your website. We will grab your HTML and we'll modify it. So in one example, in that middle one, we're optimizing images.

So we're just making sure that images use the lazy attribute or loading equals lazy. If they're off screen they're setting the decoding to be async they're setting a width and height attribute. We basically add all the attributes that you should be adding to images and we'll rerun the score and say, okay, how much will changing the way you load images, impact your lighthouse score or your performance score.

And the idea is you can usually pinpoint one or two things that are actually the most impactful, like page speed insights will tie you change a million things, but in this case, Yeah. If you optimize all those things, it'll go up a lot. Cause everybody's question is always, how do I get to 90 plus out of a hundred?

It's like, well, this will tell you in this case, the original score, I think said images were not that much of a problem for target. The score went up like five points, like whatever. That's fine. CSS is pretty on par to if we're CSS, we remove any unused styles. So we come through every style, but it's not on the page where you remove it.

We run, we run the performance. Okay. You'll see. Your CSS is pretty good. You could remove some styles and the score will go up a bit, but nothing crazy. And generally what we find is JavaScript the problem for the JavaScript test. We literally just delete all the script tags and say, how fast would it run if it just had no scripts running and that's usually see like, oh, just that one modification would get you to like an 80 out of a hundred or whatever it is doing nothing else.

And so that lets you see like, okay, that's cool. And if you have that tab still open, you could scroll down. It'll recommend some tools and it'll say, okay, if you use party town, we can run the same proxy. And instead put some of the scripts behind party town and look at the new performance score of the party town of fide site.

And usually actually we'll be able to see it in a moment. Usually you can get from like in this case, it starts at a 28. It keeps growing further, further. It's a decent ways down the page. Yeah. quick wins now. Just adding party town do as many scripts as possible could get you up to 95 from 28. That's one of the things that people are just like, tell me how to improve the score.

It's like that you should do that, right. We will show with Qwik, Qwik, the Qwik score will simulate. Basically Allscripts remove to first party scripts can be removed entirely and only laid lows when needed. And if you scroll up a little bit, we get some other tips. So in this case, we said CSS is kind of optimized.

So if you click into that, you'll see some suggestions on how to better code split it. JavaScript will recommend various projects, a couple of ours, couple of others, this and that. And this people have been enjoying it just as a way to stop banging your head against the wall. And like, what's going to move the needle and actually realize, you know, maybe a patient insights that you down this rabbit hole of something about images, but JavaScript or CSS or something else.

That's your problem all the time. So it's fun to it's in beta. If anybody watching this has feedback, please tweet at me. I'm Steve 8, 7 0 8. We'd love to see the feedback.

**Andew:** th this looks awesome. There, I shared a few podcasts back core web vitals, I think. And it's like the same thing, but this seems a lot more approachable and like a friendlier to the eye that that tool is just like, here's just everything that's possibly wrong. And it doesn't tell you if it would make it all that much better.

So I really do like having the, the improvement that you could get. Cause you can really prioritize based on.

**Steve:** Yeah, exactly. No, I'm glad you liked that. And exactly what Google rolling out core web vitals as a requirement for search ranking, it's actually like life or death. Like even if you don't believe for whatever reason that like poor performance will lead to users bouncing and poor conversions, Google literally will say you don't pass core with vitals.

We will de rank you on search. That's just your business falling through your fingertips. So yeah, hopefully you can look at this and know how you can get the score up.

**Justin:** And this is the performance insight tool. So it's builder.io/c/performance, hyphen insight insights, I guess we'll, we'll have a link in the show notes. So you can, you can definitely find it there. Yeah, this is really awesome. I am a bit of a performance nerd and have used a lot of tools over the years.

You know, the classic webpage test is great and

**Steve:** I love that

**Justin:** just, yeah, there's, there's a lot of, yeah, there are no, they're great. And they've been doing it for a while, you know, and, and you know, this, the, the shoulders that,

**Steve:** Did you

**Justin:** sort of build off of, but yeah.

**Steve:** webpage test used to be one guy who had all those devices in his garage? Like you had the phone and the, the old laptop and this and that you would be waiting in a queue to run in his garage, that a company, I forget the name acquired it, but I heard that story from someone on the team. I thought it was hilarious.

**Justin:** Yeah. I mean, I really love the, just. Innovation in this space. So there's another tool that I was using at my last company called caliber caliber is great. Just, you know, a lot of tools in this space, but yeah, definitely giving actionable insights is the number one thing you want to do with any performance insights tool.

Like what I know it sucks now, what would I do?

**Steve:** here's 5,000 things you could do. It's yeah, God would I start? Yeah.

**Justin:** Yeah, yeah.

**Andew:** Okay. And with that, I think that wraps it up for the episode. A thanks for Steve for coming on. This was a wildly interesting look into the future of webpages on or the, to the future of web. So thanks for coming on.

**Justin:** yeah,

Steve, it was awesome. Honestly, y'all done, y'all done some magical, magical work and I'm, I'm definitely excited to dig in more

**Steve:** I appreciate the time. Hit me up with any questions you've got. I'm happy to response. I'm pretty active on Twitter.

**Andew:** that's it for this week's episode of dev tools, FM, be sure to follow us on YouTube and wherever you consume your podcasts. Thanks for listening.
